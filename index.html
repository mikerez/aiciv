<!DOCTYPE html>
<html>
<head>
    <title>WebGL 2D Sprite Example</title>
</head>
<body>
                          <!-- width="400" height="300" style="width:400px;height:300px;" -->
    <canvas id="canvas3D" width="1500" height="1000"></canvas>
    <canvas id="canvas2D" width="1500" height="1000" style="position: absolute;top: 0px;left: 0px;background-color: rgba(255, 255, 255, 0);z-index: 2;"></canvas>
    <div class="container">
        <div style="position: fixed;top: 50px;right: 50px;width: 300px;height: 400px;z-index: 3;"><img src="images/eee.png"></div>
        <div id="foreground" style="position: fixed;top: 50px;right: 50px;width: 300px;height: 400px;z-index: 4;overflow-y: scroll; height:400px;">
<center><font size="5" color="darkblue" face="Courier New">Action options:</font></center>
<font size="5" color="darkblue" face="Courier New">
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Goto (G)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Fortificate (F)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Destroy (D)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Wait (W)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Irrigate (I)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Chop forrest (C)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Explore (E)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Patrol (P)</a><br>
<a onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';"">Automate (A)</a><br>
</font>
<font size="3" color="white" face="Courier New" style="background-color: rgb(50,50,50)">Buildings:</font><br>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/city.png" width="100" style="vertical-align:middle"> <font size="4">City hall</text></div>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/bbb.jpg" width="100" style="vertical-align:middle"> <font size="4">Fabric</text></div>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/big.png" width="100" style="vertical-align:middle"> <font size="4">Tank!!!!</text></div>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/aaa.jpg" width="100" style="vertical-align:middle"> <font size="4">City hall</text></div>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/bbb.jpg" width="100" style="vertical-align:middle"> <font size="4">Fabric</text></div>
<div onmouseover="this.style.backgroundColor='orange';" onmouseout="this.style.backgroundColor='';""><img src="images/big.png" width="100" style="vertical-align:middle"> <font size="4">Tank!!!!</text></div>
        </div>
    </div>
    <script>

        const _draw2D = new class
        {
            clear()
            {
                const canvas2D = document.getElementById("canvas2D");
                const ctx = canvas2D.getContext("2d");

// Set text properties
//ctx.font = "48px Arial";
//ctx.fillStyle = "white";
//ctx.fillText("Hello, WebGL!", 10, 50);  // Draws the text on the canvas
//                console.log("::: " + x + "," + y + " => " + " " + xy1toi(x,y) + ":" + xy1toj(x,y))
                ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);
                return ctx;
            }

            drawArrow(ctx, fromX, fromY, toX, toY)
            {
                const headLength = 15;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.lineTo(
                    toX - headLength * Math.cos(angle - Math.PI / 6),
                    toY - headLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - headLength * Math.cos(angle + Math.PI / 6),
                    toY - headLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            }
        }

        // very global vars
//        var _redraw = 1;
        var _fulldraw = 1;
        var sqrt2 = Math.sqrt(2)

        // we dont use class members to do not always write "this." since we use only one object of any type
        const _map_size = 100;
        const _cell_width = 200;  // by X, already multiplied by sqrt2/2
        const _cell_height = 200;  // by Y, already multiplied by sqrt2/2
        const _map_view = [_map_size/2*_cell_width,-_map_size/2*_cell_height,
                           _map_size/2*3*_cell_width,_map_size/2*_cell_height];
        const _map_terrain_tex = new Array(_map_size);
        const _map_terrain_bit = new Array(_map_size);
        // not zoomed coordinates from start of the map
        function xytoi(x,y) { return (x+y)/2/*sqrt2^2*//_cell_height; }
        function xytoj(x,y) { return (x-y)/2/*sqrt2^2*//_cell_width; }  //_map_size*sqrt2/2-
        function ijtox(i,j) { return i*_cell_height+j*_cell_width; }
        function ijtoy(i,j) { return i*_cell_height-j*_cell_width; }

        const _unit_type_textures = new Map();
        _unit_type_textures.set(0, 256);  // settler
        _unit_type_textures.set(1, 257);  // explorer
        _unit_type_textures.set(2, 258);  // warrior

        class Coord
        {
            constructor(i, j)
            {
                this.i = i
                this.j = j
            }
        }
        class Unit
        {
            constructor(type, i, j)
            {
                this.type = type;
                this.texture = _unit_type_textures.get(type);
                this.coord = new Coord(i,j);
                this.gotoCoord = null;
                this.move_penalty = 0;  // wait after difficult landshaft
                this.odd_move = 0;
            }

            setGoto(i, j)
            {
                this.gotoCoord = Coord(i,j);
            }

        }

        const _units = Array();
        _units[0] = new Unit(0, 16, 53);
        _units[1] = new Unit(0, 25, 55);
        _units[2] = new Unit(1, 13, 50);
        _units[3] = new Unit(2, 10, 51);
        _units[4] = new Unit(1, 6, 53);
        _units[5] = new Unit(2, 5, 55);
        _units[6] = new Unit(1, 3, 50);
        _units[7] = new Unit(1, 8, 51);

        var _selection = 0;
        // X,Y - screen coordinates, like event.clientX,event.clientY
        function Xtox1(X) { return X*2-_canvas.width/*/2*2*/; }
        function Ytoy1(Y) { return Y*2-_canvas.height/*/2*2*/; }
        function x1toX(x) { return (x+_canvas.width)/2/*/2*2*/; }
        function y1toY(y) { return (y+_canvas.height)/2/*/2*2*/; }
        const _control = new class
        {
            mapLine(i1, j1, i2, j2, func, k, limit)
            {
                if (Math.round(i1) < 0 || Math.round(i1) > _map_size || Math.round(j1) < 0 || Math.round(j1) > _map_size
                 || Math.round(i2) < 0 || Math.round(i2) > _map_size || Math.round(j2) < 0 || Math.round(j2) > _map_size) {
                   return;
                }

                i1 = Math.round(i1);
                i2 = Math.round(i2);
                j1 = Math.round(j1);
                j2 = Math.round(j2);

                var i = i1, pi = i1;//, pmi = 0;
                var j = j1, pj = j1;//, pmj = 0;
                var odd = _units[k].odd_move;
                while ((i != i2 || j != j2) && limit > 0) {
                    var di = i2-i;
                    var dj = j2-j;
                    var pi = i;
                    var pj = j;

                    var mi = (di > 0 ? 1 : (di < 0 ? -1 : 0));
                    var mj = (dj > 0 ? 1 : (dj < 0 ? -1 : 0));
                    if ((mi == mj || mi == -mj) && /*pmi == mi && pmj == mj*/++_units[k].step_randomizer%2==0) {  // if moving diagonal, move the direction first where distance is more
//console.log(mi + " " + mj + " " + pmi + " " + pmj)
                        if (dj > 0 && di > dj || dj < 0 && di < dj) {
                            mj = 0;
                        }
                        if (di > 0 && dj > di || di < 0 && dj < di) {
                            mi = 0;
                        }
                    }
                    if (mi == -mj && odd) {  // forbidden diagonal
                        if (++_units[k].step_randomizer%2==0) {
                            mi = 0;
                        }
                        else {
                            mj = 0;
                        }
                    }
//                    pmi = mi
//                    pmj = mj
                    i += mi
                    j += mj

                    if (Math.round(pi) < 0 || Math.round(pi) > _map_size || Math.round(pj) < 0 || Math.round(pj) > _map_size
                         || (_map_terrain_tex[Math.round(pi)][Math.round(pj)]&0x0F) == 0) {
                        break;
                    }
                    func(Math.round(pi), Math.round(pj), Math.round(i), Math.round(j), mi==1&&mj==1?0:mi==1&&mj==0?1:mi==1&&mj==-1?2:mi==0&&mj==-1?3:mi==-1&&mj==-1?4:mi==-1&&mj==0?5:mi==-1&&mj==1?6:7);
                    --limit;
                    odd = 1-odd;
                }
            }

            drawGoto(i1, j1, i2, j2, k)
            {
                var ctx = _draw2D.clear();
                _units[k].step_randomizer = 0;
                this.mapLine(i1, j1, i2, j2, function(i, j, ni, nj, arrow_num) {
//console.log(":::" + i + ":" + j)
//                    _screen.drawSprite(ijtox1(i,j), ijtoy1(i,j), 514+arrow_num, _screenZoom);
                    var ix = arrow_num==0?10:arrow_num==1?5:arrow_num==2?0:arrow_num==3?-5:arrow_num==4?-10:arrow_num==5?-5:arrow_num==6?0:(5);
                    var iy = arrow_num==0?0:arrow_num==1?5:arrow_num==2?10:arrow_num==3?5:arrow_num==4?0:arrow_num==5?-5:arrow_num==6?-10:(-5);
                    _draw2D.drawArrow(ctx, x1toX(ijtox1(i,j))+5-ix, y1toY(ijtoy1(i,j))+5-iy, x1toX(ijtox1(i,j))+5+ix, y1toY(ijtoy1(i,j))+5+iy);
                }, k, 30)
                _units[k].step_randomizer = 0;
            }

            click(x, y)
            {
                for (k=0; k < _units.length; k++) {
                    if (x > ijtox1(_units[k].coord.i,_units[k].coord.j)-10 && x < ijtox1(_units[k].coord.i,_units[k].coord.j) + 200
                     && y > ijtoy1(_units[k].coord.i,_units[k].coord.j)-10 && y < ijtoy1(_units[k].coord.i,_units[k].coord.j) + 150) {
                        _selection = k;
//                        _redraw = 1;
                        break;
                    }
                }                
            }

        }

        const _game = new class
        {
            makeTurn()
            {
                for (k=0; k < _units.length; k++) {
                    if (_units[k].gotoCoord != undefined) {
                        if (_units[k].move_penalty) {
                            --_units[k].move_penalty;
                            continue;
                        }
//console.log("goto: " + k + " (" + _units[k].coord.i + "," + _units[k].coord.j + ") to (" + _units[k].gotoCoord.i + "," + _units[k].gotoCoord.j + ")");
                        var prev = _units[k].coord;
                        _control.mapLine(_units[k].coord.i, _units[k].coord.j, _units[k].gotoCoord.i, _units[k].gotoCoord.j, function(i, j, ni, nj, arrow_num) {
                            _units[k].odd_move = 1-_units[k].odd_move;
                            _units[k].coord = new Coord(ni, nj);
                        }, k, 1)
                        if (_units[k].coord != prev) {
                            _units[k].move_penalty = (_map_terrain_tex[_units[k].coord.i][_units[k].coord.j]>>4)&0x3;
//console.log(_units[k].move_penalty)
                        }

                        if (_units[k].coord == _units[k].gotoCoord) {
                            _units[k].gotoCoord = null;
                        }
                    }
                }
            }
        }

        const _map = new class
        {
            init()
            {
                for (var i=0; i < _map_size; i++) {
                    _map_terrain_tex[i] = new Array(_map_size);
                    _map_terrain_bit[i] = new Array(_map_size);
                }

                for (var i=0; i < _map_size; i++) {
                    for (var j=0; j<_map_size; j++) {
                        _map_terrain_tex[i][j] = 0;
                        _map_terrain_bit[i][j] = 0xFF;
                    }
                }
            }

            genMap(num, msteps, mwidth, mbranch, min_x, min_y, max_x, max_y, type, op)
            {
                for (var pass=0; pass<num; pass++) {
                    var steps = Math.round(Math.random()*msteps)+msteps
                    var rnd1 = Math.random();
                    var rnd2 = Math.random();
                    var bj = Math.round(xytoj(min_x + rnd1*(max_x-min_x), min_y + rnd2*(max_y-min_y)))
                    var bi = Math.round(xytoi(min_x + rnd1*(max_x-min_x), min_y + rnd2*(max_y-min_y)))
                    for (var branch=0; branch < mbranch + Math.round(Math.random()*1); branch++) {
                        var width = Math.round(Math.random()*mwidth)+mwidth
                        var dir_j = (Math.random()-0.5)/3;
                        var dir_i = (Math.random()-0.5)/3;
                        var j1 = bj;
                        var i1 = bi;
                        for (var step=0; step < steps; step++) {
                            j1 += dir_j;
                            i1 += dir_i;
                            dir_j += (Math.random()-0.5)/3;
                            dir_i += (Math.random()-0.5)/3;
                            var j = j1;
                            var i = i1;
                            width = mwidth + Math.round(Math.random()*1);
                            if (width < 0) width = mwidth;
                            for (var r=0; r < width; r++) {
                                j += dir_i;
                                i += dir_j;
                                var x = ijtox(i,j)
                                var y = ijtoy(i,j)
                                var ri = Math.round(i)
                                var rj = Math.round(j)
                                if (rj >= 0 && rj < _map_size && Math.round(i) >= 0 && Math.round(i) < _map_size
                                   && x >= min_x && y >= min_y && x < max_x && y < max_y) {
                                    if (op == 0) {  // just set
                                        _map_terrain_tex[ri][rj] = type;
                                    }
                                    else
                                    if (op == 1 && (_map_terrain_tex[ri][rj]&0x0F)) {  // no water
                                        _map_terrain_tex[ri][rj] = type;
                                    }
                                    else
                                    if (op == 2 && (_map_terrain_tex[ri][rj]>>4) != 1) {  // mod terrain heights
                                        var was = _map_terrain_tex[ri][rj]>>4
                                        _map_terrain_tex[ri][rj] &= 0x0F;
                                        _map_terrain_tex[ri][rj] |= (was==0?3:(was-1))<<4;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            fixMap()
            {
                for (var i=1; i < _map_size-1; i++) {
                    for (var j=1; j < _map_size-1; j++) {
                        // sand near to water
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i+1][j] == 2 && ijtoy(i,j) > _map_view[1]+(_map_view[3]-_map_view[1])/3 && ijtoy(i,j) < _map_view[3]-(_map_view[3]-_map_view[1])/3) _map_terrain_tex[i+1][j] = 1;
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i][j+1] == 2 && ijtoy(i,j) > _map_view[1]+(_map_view[3]-_map_view[1])/3 && ijtoy(i,j) < _map_view[3]-(_map_view[3]-_map_view[1])/3) _map_terrain_tex[i][j+1] = 1;
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i-1][j] == 2 && ijtoy(i,j) > _map_view[1]+(_map_view[3]-_map_view[1])/3 && ijtoy(i,j) < _map_view[3]-(_map_view[3]-_map_view[1])/3) _map_terrain_tex[i-1][j] = 1;
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i][j-1] == 2 && ijtoy(i,j) > _map_view[1]+(_map_view[3]-_map_view[1])/3 && ijtoy(i,j) < _map_view[3]-(_map_view[3]-_map_view[1])/3) _map_terrain_tex[i][j-1] = 1;
                        // shallow water near to land
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i+1][j] != 0) _map_terrain_tex[i][j] = 0+(1<<4);
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i][j+1] != 0) _map_terrain_tex[i][j] = 0+(1<<4);
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i-1][j] != 0) _map_terrain_tex[i][j] = 0+(1<<4);
                        if (_map_terrain_tex[i][j] == 0 && _map_terrain_tex[i][j-1] != 0) _map_terrain_tex[i][j] = 0+(1<<4);
                    }
                }
            }

            enhMap()
            {
                for (var i=0; i < _map_size-1; i++) {
                    for (var j=0; j < _map_size-1; j++) {
                        for (var k=0; k < 16; k++) {
                            for (var l=0; l < 4; l++) {
                                if (_textures[k+((l+4)<<4)] !== undefined
                                 && (_map_terrain_tex[i][j]&0x3F) == k+(l<<4) && (_map_terrain_tex[i+1][j]&0x3F) == k+(l<<4)
                                 && (_map_terrain_tex[i][j+1]&0x3F) == k+(l<<4) && (_map_terrain_tex[i+1][j+1]&0x3F) == k+(l<<4)
                                 /*&& (_map_terrain_tex[i][j]&0x30)+(_map_terrain_tex[i+1][j]&0x30)+(_map_terrain_tex[i][j+1]&0x30)+(_map_terrain_tex[i+1][j+1]&0x30) < 0xC0*/) {
//                                     _map_terrain_tex[i][j] = k+((l+4)<<4);
                                     _map_terrain_tex[i+1][j] = k+((l+4)<<4);
//                                     _map_terrain_tex[i][j+1] = k+((l+4)<<4);
                                     _map_terrain_tex[i+1][j+1] = k+((l+4)<<4);
if ((_map_terrain_tex[i+1][j]&0xF)==4) {  // shadows
    if ((_map_terrain_tex[i+2][j+1]&0xF)!=4) _map_terrain_bit[i+2][j+1] |= 1<<8;
    if ((_map_terrain_tex[i+1][j+2]&0xF)!=4) _map_terrain_bit[i+1][j+2] |= 1<<8;
    if ((_map_terrain_tex[i+2][j+2]&0xF)!=4) _map_terrain_bit[i+2][j+2] |= 1<<8;
}
                                }
                            }
                        }
                        if (_map_terrain_tex[i][j]==4+((1+4)<<4) && Math.random() > 0.5) {
                            _map_terrain_tex[i][j] |= 8<<4;
                        }
                        if (_map_terrain_tex[i][j]==4+((4)<<4) && Math.random() > 0.5) {
                            _map_terrain_tex[i][j] |= 8<<4;
                        }
                        if (_map_terrain_tex[i][j]==2+((2+4)<<4) && Math.random() > 0.5) {
//                            _map_terrain_tex[i][j] |= 8<<4;
                        }

                        if ((_map_terrain_tex[i][j]&0x0F) != 0) {
                            _map_terrain_bit[i][j] &= 0xFFF0;
                            _map_terrain_bit[i][j] |= (_map_terrain_tex[i][j]>>4)&0x3;
                        }
                    }
                }
            }

            gen()
            {
                this.genMap(10, 20, 30, 10, _map_view[0], _map_view[1], _map_view[2], _map_view[3], 2, 0);  // grass
                this.genMap(14, 10, 5, 5, _map_view[0], _map_view[1]+(_map_view[3]-_map_view[1])/3, _map_view[2], _map_view[3]-(_map_view[3]-_map_view[1])/3, 1, 1);  // sand
                this.genMap(20, 2, 5, 2, _map_view[0], _map_view[1]+(_map_view[3]-_map_view[1])/3, _map_view[2], _map_view[3]-(_map_view[3]-_map_view[1])/3, 5, 1);  // rocks
                this.genMap(10, 10, 5, 5, _map_view[0], _map_view[1], _map_view[2], _map_view[3], 4, 1);  // hills
                this.genMap(20, 10, 10, 5, _map_view[0], _map_view[1], _map_view[2], _map_view[3], 6, 1);  // forest
                this.genMap(10, 10, 10, 5, _map_view[0], _map_view[1], _map_view[2], _map_view[1]+(_map_view[3]-_map_view[1])/10, 3, 1);  // snow
                this.genMap(10, 10, 10, 5, _map_view[0], _map_view[3]-(_map_view[3]-_map_view[1])/10, _map_view[2], _map_view[3], 3, 1);  // snow
                this.fixMap();  // before mod tiles
                this.genMap(30, 20, 5, 5, _map_view[0], _map_view[1], _map_view[2], _map_view[3], -1, 2);  // mods
                this.genMap(10, 20, 1, 1, _map_view[0], _map_view[1], _map_view[2], _map_view[3], 0+(1<<4), 0);  // wide rivers
                this.genMap(6, 10, 1, 1, _map_view[0], _map_view[1]+(_map_view[3]-_map_view[1])/10, _map_view[2], _map_view[3]-(_map_view[3]-_map_view[1])/10, 7+(3<<4), 1);  // narrow rivers
                this.enhMap();
            }
        }

        const _textures = new Array(1024);  // first 256 are map tiles

        var _canvas = document.getElementById("canvas3D");
        var _gl = _canvas.getContext("webgl", { antialias: false, alpha: false, depth: false, stencil: false, powerPreference: "low-power", preserveDrawingBuffer: true });
        const _ratio = window.devicePixelRatio;
        var _screenZoom = 4;
        var _screenOffsetX = _map_view[0]/_screenZoom+_canvas.width*2;
        var _screenOffsetY = _map_view[1]/_screenZoom-_canvas.height*2;
        // xy1 - *2 coordinates, starting from center of the screen
        function xy1toi(x,y) { return (x*_screenZoom+_screenOffsetX*2*_ratio+y*_screenZoom+_screenOffsetY*2*_ratio)/2/_cell_height; }
        function xy1toj(x,y) { return (x*_screenZoom+_screenOffsetX*2*_ratio-y*_screenZoom-_screenOffsetY*2*_ratio)/2/_cell_width; }  //_map_size*sqrt2/2-
        function ijtox1(i,j) { return (i*_cell_height + j*_cell_width - _screenOffsetX*2*_ratio)/_screenZoom; }
        function ijtoy1(i,j) { return (i*_cell_height - j*_cell_width - _screenOffsetY*2*_ratio)/_screenZoom; }
        const _screen = new class
        {
//var desiredCSSWidth = 400;
//var desiredCSSHeight = 300;
//var devicePixelRatio = window.devicePixelRatio || 1;

//canvas.width  = (desiredCSSWidth  * devicePixelRatio)/1.05;
//canvas.height = (desiredCSSHeight * devicePixelRatio)/1.05;
//Math.floor
//canvas.style.width  = desiredCSSWidth  + "px";
//canvas.style.height = desiredCSSHeight + "px";

//        const ratio = window.devicePixelRatio;
//        canvas.width = canvas.getBoundingClientRect().width * ratio;
//        canvas.height = canvas.getBoundingClientRect().height * ratio;

            init()
            {
                if (!_gl) {
                    console.error("WebGL not supported, falling back on experimental-webgl");
                    _gl = _canvas.getContext("experimental-webgl");
                }

                if (!_gl) {
                    alert("Your browser does not support WebGL");
                }

                this.shaderProgram = this.initShaderProgram();
                this.programInfo = {
                    program: this.shaderProgram,
                    attribLocations: {
                        vertexPosition: _gl.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
                        textureCoord: _gl.getAttribLocation(this.shaderProgram, 'aTextureCoord'),
                    },
                    uniformLocations: {
                        sampler: _gl.getUniformLocation(this.shaderProgram, 'uSampler'),
                        brightness: _gl.getUniformLocation(this.shaderProgram, 'uBrightness'),
                    },
                };
            }

            constructor()
            {
                // we need to put this persistent vars somewhere

                // Vertex shader program
                this.vsSource = `
                    attribute vec2 aVertexPosition;
                    attribute vec2 aTextureCoord;
                    varying highp vec2 vTextureCoord;
                    uniform mat4 uProjectionMatrix;
                    void main(void) {
                        gl_Position = vec4(aVertexPosition, 0.0, 1);
                        vTextureCoord = aTextureCoord;
                    }
                `;

                // Fragment shader program
                this.fsSource = `
                    varying highp vec2 vTextureCoord;
                    uniform sampler2D uSampler;
                    uniform mediump float uBrightness;
                    void main(void) {
                        gl_FragColor = texture2D(uSampler, vTextureCoord);
                        gl_FragColor = gl_FragColor * uBrightness;
                    }
                `;
            }

            loadShader(type, source)
            {
                const shader = _gl.createShader(type);
                _gl.shaderSource(shader, source);
                _gl.compileShader(shader);
                if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + _gl.getShaderInfoLog(shader));
                    _gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            initShaderProgram()
            {
                const vertexShader = this.loadShader(_gl.VERTEX_SHADER, this.vsSource);
                const fragmentShader = this.loadShader(_gl.FRAGMENT_SHADER, this.fsSource);

                const shaderProgram = _gl.createProgram();
                _gl.attachShader(shaderProgram, vertexShader);
                _gl.attachShader(shaderProgram, fragmentShader);
                _gl.linkProgram(shaderProgram);

                if (!_gl.getProgramParameter(shaderProgram, _gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + _gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                return shaderProgram;
            }

            loadTexture(url, id)
            {
                function onLoadImage(image, texture) {
                    const internalFormat = _gl.RGBA;
                    const srcFormat = _gl.RGBA;
                    const srcType = _gl.UNSIGNED_BYTE;
                    _gl.bindTexture(_gl.TEXTURE_2D, texture);
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, srcFormat, srcType, image);
//                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
//                        _gl.generateMipmap(_gl.TEXTURE_2D);
//                    } else {
                        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
//                    }
                    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
                    _gl.enable(_gl.BLEND);
                }

                _textures[id] = _gl.createTexture();
                const image = new Image();
                image.onload = function() { onLoadImage(image, _textures[id]); }
                image.src = "images/" + url;
            }

//            isPowerOf2(value) {
//                return (value & (value - 1)) == 0;
//            }

            drawSprite(x, y, type, zoom)
            {
                var positionBuffer = _gl.createBuffer();
                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                var positions = [
                    1/_canvas.width*(-220/zoom+x),  1/_canvas.height*(160/zoom-y),
                    1/_canvas.width*(-220/zoom+x), 1/_canvas.height*(-160/zoom-y),
                    1/_canvas.width*(220/zoom+x),  1/_canvas.height*(160/zoom-y),
                    1/_canvas.width*(220/zoom+x), 1/_canvas.height*(-160/zoom-y),
                ];
                _gl.bufferData(_gl.ARRAY_BUFFER, new Float32Array(positions), _gl.STATIC_DRAW);

                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                _gl.vertexAttribPointer(this.programInfo.attribLocations.vertexPosition, 2, _gl.FLOAT, false, 0, 0);
                _gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

                _gl.activeTexture(_gl.TEXTURE0);
                //Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)<0?0:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)>3?3:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)
                _gl.bindTexture(_gl.TEXTURE_2D, _textures[type]);
                _gl.uniform1i(this.programInfo.uniformLocations.sampler, 0);
                _gl.uniform1f(this.programInfo.uniformLocations.brightness, 1.0);

                _gl.drawArrays(_gl.TRIANGLE_STRIP, 0, 4);
            }

            drawSprite1(x, y, type, zoom)
            {
                var positionBuffer = _gl.createBuffer();
                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                var positions = [
                    1/_canvas.width*(-420/zoom+x),  1/_canvas.height*(310/zoom-y),
                    1/_canvas.width*(-420/zoom+x), 1/_canvas.height*(-310/zoom-y),
                    1/_canvas.width*(420/zoom+x),  1/_canvas.height*(310/zoom-y),
                    1/_canvas.width*(420/zoom+x), 1/_canvas.height*(-310/zoom-y),
                ];
                _gl.bufferData(_gl.ARRAY_BUFFER, new Float32Array(positions), _gl.STATIC_DRAW);

                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                _gl.vertexAttribPointer(_screen.programInfo.attribLocations.vertexPosition, 2, _gl.FLOAT, false, 0, 0);
                _gl.enableVertexAttribArray(_screen.programInfo.attribLocations.vertexPosition);

                _gl.activeTexture(_gl.TEXTURE0);
                //Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)<0?0:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)>3?3:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)
                _gl.bindTexture(_gl.TEXTURE_2D, _textures[type]);
                _gl.uniform1i(_screen.programInfo.uniformLocations.sampler, 0);
                _gl.uniform1f(this.programInfo.uniformLocations.brightness, 1.0);

                _gl.drawArrays(_gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        _screen.init();
        // [R A D D T T T T], T - type 4 bit, D - depth/height/wildity, A - 4 blocks aggregation of similar type
        _screen.loadTexture('waterdeep1.png', 0);
         _screen.loadTexture('water.png', 0+(1<<4));  // deep
         _screen.loadTexture('waterdeep.png', 0+(2<<4));  // deep
         _screen.loadTexture('waterdeep.png', 0+(3<<4));  // deep
//         _screen.loadTexture('water-1.png', 0+(8<<4));  // deep
//         _screen.loadTexture('water4.png', 0+(4<<4));  // deep
        _screen.loadTexture('sand.png', 1);
         _screen.loadTexture('sanddune3.png', 1+(1<<4));
         _screen.loadTexture('sand2.png', 1+(2<<4));
         _screen.loadTexture('sanddune1.png', 1+(3<<4));
         _screen.loadTexture('sandbig.png', 1+(4<<4));
         _screen.loadTexture('sanddune3.png', 1+(5<<4));
         _screen.loadTexture('sand6.png', 1+((2+4)<<4));
         _screen.loadTexture('sand10.png', 1+((2+8)<<4));
         _screen.loadTexture('sand14.png', 1+((8+2+4)<<4));
        _screen.loadTexture('grass.png', 2);
         _screen.loadTexture('grass_wet.png', 2+(1<<4));
         _screen.loadTexture('grass_offroad.png', 2+(2<<4));
         _screen.loadTexture('grass_swamps.png', 2+(3<<4));  //swamps
        _screen.loadTexture('snow.png', 3);
          _screen.loadTexture('snowhill.png', 3+(1<<4));
          _screen.loadTexture('snowhill1.png', 3+(2<<4));
          _screen.loadTexture('snowhill2.png', 3+(3<<4));
        _screen.loadTexture('hills.png', 4);
          _screen.loadTexture('hills1.png', 4+(1<<4));
          _screen.loadTexture('hills2.png', 4+(2<<4));
          _screen.loadTexture('hills3.png', 4+(3<<4));
          _screen.loadTexture('hills4.png', 4+(4<<4));
          _screen.loadTexture('hills5.png', 4+((1+4)<<4));
          _screen.loadTexture('hills6.png', 4+((2+4)<<4));
          _screen.loadTexture('hills12.png', 4+((8+4)<<4));
          _screen.loadTexture('hills13.png', 4+((8+1+4)<<4));
        _screen.loadTexture('rocks.png', 5);
          _screen.loadTexture('rocks.png', 5+(1<<4));
          _screen.loadTexture('rocks2.png', 5+(2<<4));
          _screen.loadTexture('rocks1.png', 5+(3<<4));
        _screen.loadTexture('forest.png', 6);
         _screen.loadTexture('forest1.png', 6+(1<<4));
         _screen.loadTexture('forest2.png', 6+(2<<4));
         _screen.loadTexture('forest3.png', 6+(3<<4));
         _screen.loadTexture('forest7.png', 6+(7<<4));
        _screen.loadTexture('grasswater.png', 7+(3<<4));

        _screen.loadTexture('city.png', 256);
        _screen.loadTexture('explorer.png', 257);
        _screen.loadTexture('warrior.png', 258);
        _screen.loadTexture('select.png', 512);
        _screen.loadTexture('select1.png', 513);
        _screen.loadTexture('arrow1.png', 514);
        _screen.loadTexture('arrow2.png', 515);
        _screen.loadTexture('arrow3.png', 516);
        _screen.loadTexture('arrow4.png', 517);
        _screen.loadTexture('arrow5.png', 518);
        _screen.loadTexture('arrow6.png', 519);                                      +

        _map.init();
        _map.gen();

        var _shift_pressed = 0;
        var _ctrl_pressed = 0;
        var _mousedown = 0;
        var _step = 0;
        var _in_drawing = 0;

        function drawScene(loop)
        {
            const startTime = performance.now();
            if (loop) {
                _fulldraw = 1;
            }
            _in_drawing = 1;
//            _gl.viewport(0, 0, _canvas.width*ratio, _canvas.height*ratio);
            if (_fulldraw) {
                _gl.clearColor(0.2, 0.2, 0.2, 0.2);
                _gl.clear(_gl.COLOR_BUFFER_BIT/* | _gl.DEPTH_BUFFER_BIT*/);

                _gl.useProgram(_screen.programInfo.program);
            }

            // this is const for all sprites
            this.textureCoordBuffer = _gl.createBuffer();
            _gl.bindBuffer(_gl.ARRAY_BUFFER, this.textureCoordBuffer);
            const textureCoordinates = [
                0.0,  0.0,
                0.0,  1.0,
                1.0,  0.0,
                1.0,  1.0,
            ];
            _gl.bufferData(_gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), _gl.STATIC_DRAW);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, this.textureCoordBuffer);
            _gl.vertexAttribPointer(_screen.programInfo.attribLocations.textureCoord, 2, _gl.FLOAT, false, 0, 0);
            _gl.enableVertexAttribArray(_screen.programInfo.attribLocations.textureCoord);
            //
            var start_i = Math.round(xytoi(_screenOffsetX*2*_ratio, _screenOffsetY*2*_ratio) - _canvas.width/2*2*_ratio/_cell_height*_screenZoom) - 1;
            var start_j = Math.round(xytoj(_screenOffsetX*2*_ratio, _screenOffsetY*2*_ratio) - _canvas.width/2*2*_ratio/_cell_height*_screenZoom);
            var height_i = Math.round(_canvas.width/2*2/_cell_height*_screenZoom*2.6);
            var width_j = Math.round(_canvas.height/2*2/_cell_width*_screenZoom*3.6)+1;
            if (start_i < 0) {
                start_i = 0;
            }
            if (start_j < 0) {
                start_j = 0;
            }
            if (start_i + height_i >= _map_size) {
                height_i = _map_size - start_i - 1
            }
            if (start_j + width_j >= _map_size) {
                width_j = _map_size - start_j - 1
            }
            WIDTH=1/_canvas.width
            HEIGHT=1/_canvas.height
            STARTX=220/_screenZoom
            STARTY=160/_screenZoom
            for (i=start_i; i < start_i + height_i; ++i) {
                for (j=start_j + width_j; j >= start_j; --j) {
//                    if (j >= 0 && i >= 0 && j < _map_size && i < _map_size) 
{
//                         alert(i)
//                         alert(j)
//                    x = i*200+j*200;
//                    y = i*200-j*200;
//////////////                        _step++;
                        if (/*_map_terrain_tex[i][j]==(0+(1<<4))&&_step%2 ||*/ _fulldraw) {
                            // - _map_view[0]* /*20*/0*sqrt2
                            // - _map_view[1]* /*20*/0*sqrt2 

                // inlined drawSprite
                var positionBuffer = _gl.createBuffer();
                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                var positions = [
                    WIDTH*(-STARTX+ijtox1(i,j)),  HEIGHT*(STARTY-ijtoy1(i,j)),
                    WIDTH*(-STARTX+ijtox1(i,j)), HEIGHT*(-STARTY-ijtoy1(i,j)),
                    WIDTH*(STARTX+ijtox1(i,j)),  HEIGHT*(STARTY-ijtoy1(i,j)),
                    WIDTH*(STARTX+ijtox1(i,j)), HEIGHT*(-STARTY-ijtoy1(i,j)),
                ];
                _gl.bufferData(_gl.ARRAY_BUFFER, new Float32Array(positions), _gl.STATIC_DRAW);

                _gl.bindBuffer(_gl.ARRAY_BUFFER, positionBuffer);
                _gl.vertexAttribPointer(_screen.programInfo.attribLocations.vertexPosition, 2, _gl.FLOAT, false, 0, 0);
                _gl.enableVertexAttribArray(_screen.programInfo.attribLocations.vertexPosition);

                _gl.activeTexture(_gl.TEXTURE0);
                //Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)<0?0:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)>3?3:Math.floor(3.5-((i-3)*(i-3)+(j-3)*(j-3))/5.5)
//                if (_textures[_map_terrain_tex[i][j]/*&~(4<<4)*/] === undefined) alert("Undefined struct " + (_map_terrain_tex[i][j]/*&~(4<<4*/));
                _gl.bindTexture(_gl.TEXTURE_2D, _textures[_map_terrain_tex[i][j]/*&~(4<<4)*/]);
                _gl.uniform1i(_screen.programInfo.uniformLocations.sampler, 0);
                _gl.uniform1f(_screen.programInfo.uniformLocations.brightness, 1.0-(_map_terrain_bit[i][j]>>8)*0.1);

                _gl.drawArrays(_gl.TRIANGLE_STRIP, 0, 4);


//                            _screen.drawSprite(ijtox1(i,j), ijtoy1(i,j), /*(_map_terrain_tex[i][j]==(0+(1<<4))&&_step%2)?8<<4:*/_map_terrain_tex[i][j]&~(4<<4), _screenZoom);
                            if (((_map_terrain_tex[i][j]>>4)&4) /*&& ((_map_terrain_tex[i-1][j]>>4)&4) == 0 && ((_map_terrain_tex[i][j-1]>>4)&4) == 0*/) {
                                _screen.drawSprite1(ijtox1(i,j) - _cell_width/_screenZoom/3, ijtoy1(i,j) - _cell_height/_screenZoom/10, _map_terrain_tex[i][j], _screenZoom);
                            }
//, 1.0-(_map_terrain_bit>>8)
                        }
                    }
                }
            }

            if (_selection != -1) {
                _screen.drawSprite(ijtox1(_units[_selection].coord.i,_units[_selection].coord.j), ijtoy1(_units[_selection].coord.i,_units[_selection].coord.j),
                                   _step%2?512:513, _screenZoom);
                _screen.drawSprite(ijtox1(_units[_selection].i,_units[_selection].j), ijtoy1(_units[_selection].i,_units[_selection].j),
                                   _units[_selection].texture, _screenZoom);
            }

            if (_fulldraw) {
                for (k=0; k < _units.length; k++) {
                    _screen.drawSprite(ijtox1(_units[k].coord.i,_units[k].coord.j), ijtoy1(_units[k].coord.i,_units[k].coord.j),
                                       _units[k].texture, _screenZoom);
                }
            }

            if (_fulldraw) {
                const endTime = performance.now();
                const executionTime = endTime - startTime;
                const foregroundDiv = document.getElementById('foreground');
//                foregroundDiv.textContent = '<br>FPS: ' + (1000 / executionTime).toFixed(2);
            }

            _step++;
//            _redraw = 0;
            _fulldraw = 0;
            if (loop) {
                setTimeout(drawScene, 700, 1);
            }
            _in_drawing = 0;
        }


        setTimeout(drawScene, 700, 1);

        window.onmousedown = function(event) {
            _control.click(Xtox1(event.pageX), Ytoy1(event.pageY));
            drawScene(0);
            _mousedown = 1;
        }

        window.onmousemove = function(event) {
            if (_mousedown && _selection != -1) {
                _control.drawGoto(_units[_selection].coord.i, _units[_selection].coord.j, xy1toi(Xtox1(event.clientX),Ytoy1(event.clientY)), xy1toj(Xtox1(event.clientX),Ytoy1(event.clientY)), _selection);
                _units[_selection].gotoCoord = new Coord(xy1toi(Xtox1(event.clientX),Ytoy1(event.clientY)), xy1toj(Xtox1(event.clientX),Ytoy1(event.clientY)));
            }
        }

        window.onmouseup = function(event) {
            if (_mousedown && _selection != -1) {
                
            }
            _mousedown = 0;
        }

        document.body.onkeydown = function(event) {
            if (event.shiftKey) {
                _shift_pressed = 1;
            }
            else {
                _shift_pressed = 0;
            }
            if (event.ctrlKey) {
                _ctrl_pressed = 1;
            }
            else {
                _ctrl_pressed = 0;
            }
            if (event.code === 'Enter') {
                _game.makeTurn();
                _fullredraw = 1;
                drawScene(0);
            }
        };

        document.body.onkeyup = function(event) {
            if (event.shiftKey) {
                _shift_pressed = 1;
            }
            else {
                _shift_pressed = 0;
            }
            if (event.ctrlKey) {
                _ctrl_pressed = 1;
            }
            else {
                _ctrl_pressed = 0;
            }

        };

        window.onscroll = function(event) {
//            _redraw = 1;
//           setTimeout(drawScene, 100);
        }

        function checkScrollTimeout(X, Y)
        {
            if (_screenOffsetX == X && _screenOffsetY == Y) {
                _scroll_step = 4;
            }
        }

        var _scroll_step = 4;
        document.addEventListener("wheel", (event) => {
          event.preventDefault();
          event.stopPropagation();
          _draw2D.clear();

          if (_ctrl_pressed) {
              _screenZoom -= event.deltaY>0?-0.2:0.2;
              if (_screenZoom < 1) {
                  _screenZoom = 1;
              }
              if (_screenZoom > 5) {
                  _screenZoom = 5;
              }
              _fulldraw = 1;
//              _redraw = 1;
          }
          else
          for (k=0; k<_scroll_step; ++k) {
              if (!_shift_pressed) {
                  _screenOffsetY -= event.deltaY>0?-_screenZoom/5:_screenZoom/5;
              }
              else {
                  _screenOffsetX -= event.deltaY>0?-_screenZoom/5:_screenZoom/5;
              }
              _fulldraw = 1;
//              _redraw = 1;
              if (!_in_drawing) {
                  setTimeout(drawScene, 0, 0);
              }
          }
                  setTimeout(drawScene, 0, 0);

//drawScene(0);
          _scroll_step = _scroll_step>128?_scroll_step:_scroll_step*2;
          setTimeout(checkScrollTimeout, 500, _screenOffsetX, _screenOffsetY);
          // now define custom functionality
        }, { passive: false });

   </script>
</body>
</html>
